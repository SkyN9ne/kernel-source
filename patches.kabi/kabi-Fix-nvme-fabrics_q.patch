From: Enzo Matsumiya <ematsumiya@suse.de>
Patch-mainline: Never, kabi fix
Subject: fix kABI breakage in NVMe driver
References: bsc#1181161

Use admin_q when __GENKSYMS__ is set. Otherwise, use the new fabrics_q member.

This is related to the changes introduced in patch
patches.suse/nvme-make-fabrics-command-run-on-a-separate-request-.patch

--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@ -165,7 +165,9 @@ struct nvme_ctrl {
 	const struct nvme_ctrl_ops *ops;
 	struct request_queue *admin_q;
 	struct request_queue *connect_q;
+#ifndef __GENKSYMS__
 	struct request_queue *fabrics_q;
+#endif
 	struct device *dev;
 	int instance;
 	int numa_node;
--- a/drivers/nvme/host/fabrics.c
+++ b/drivers/nvme/host/fabrics.c
@@ -158,8 +158,13 @@ int nvmf_reg_read32(struct nvme_ctrl *ct
 	cmd.prop_get.fctype = nvme_fabrics_type_property_get;
 	cmd.prop_get.offset = cpu_to_le32(off);
 
+#ifdef __GENKSYMS__
+	ret = __nvme_submit_sync_cmd(ctrl->admin_q, &cmd, &res, NULL, 0, 0,
+			NVME_QID_ANY, 0, 0);
+#else
 	ret = __nvme_submit_sync_cmd(ctrl->fabrics_q, &cmd, &res, NULL, 0, 0,
 			NVME_QID_ANY, 0, 0);
+#endif
 
 	if (ret >= 0)
 		*val = le64_to_cpu(res.u64);
@@ -205,8 +210,13 @@ int nvmf_reg_read64(struct nvme_ctrl *ct
 	cmd.prop_get.attrib = 1;
 	cmd.prop_get.offset = cpu_to_le32(off);
 
+#ifdef __GENKSYMS__
+	ret = __nvme_submit_sync_cmd(ctrl->admin_q, &cmd, &res, NULL, 0, 0,
+			NVME_QID_ANY, 0, 0);
+#else
 	ret = __nvme_submit_sync_cmd(ctrl->fabrics_q, &cmd, &res, NULL, 0, 0,
 			NVME_QID_ANY, 0, 0);
+#endif
 
 	if (ret >= 0)
 		*val = le64_to_cpu(res.u64);
@@ -251,8 +261,13 @@ int nvmf_reg_write32(struct nvme_ctrl *c
 	cmd.prop_set.offset = cpu_to_le32(off);
 	cmd.prop_set.value = cpu_to_le64(val);
 
+#ifdef __GENKSYMS__
+	ret = __nvme_submit_sync_cmd(ctrl->admin_q, &cmd, NULL, NULL, 0, 0,
+			NVME_QID_ANY, 0, 0);
+#else
 	ret = __nvme_submit_sync_cmd(ctrl->fabrics_q, &cmd, NULL, NULL, 0, 0,
 			NVME_QID_ANY, 0, 0);
+#endif
 	if (unlikely(ret))
 		dev_err(ctrl->device,
 			"Property Set error: %d, offset %#x\n",
@@ -404,9 +419,15 @@ int nvmf_connect_admin_queue(struct nvme
 	strncpy(data->subsysnqn, ctrl->opts->subsysnqn, NVMF_NQN_SIZE);
 	strncpy(data->hostnqn, ctrl->opts->host->nqn, NVMF_NQN_SIZE);
 
+#ifdef __GENKSYMS__
+	ret = __nvme_submit_sync_cmd(ctrl->admin_q, &cmd, &res,
+			data, sizeof(*data), 0, NVME_QID_ANY, 1,
+			BLK_MQ_REQ_RESERVED | BLK_MQ_REQ_NOWAIT);
+#else
 	ret = __nvme_submit_sync_cmd(ctrl->fabrics_q, &cmd, &res,
 			data, sizeof(*data), 0, NVME_QID_ANY, 1,
 			BLK_MQ_REQ_RESERVED | BLK_MQ_REQ_NOWAIT);
+#endif
 	if (ret) {
 		nvmf_log_connect_error(ctrl, ret, le32_to_cpu(res.u32),
 				       &cmd, data);
--- a/drivers/nvme/host/fc.c
+++ b/drivers/nvme/host/fc.c
@@ -2043,7 +2043,9 @@ nvme_fc_ctrl_free(struct kref *ref)
 
 	blk_mq_unquiesce_queue(ctrl->ctrl.admin_q);
 	blk_cleanup_queue(ctrl->ctrl.admin_q);
+#ifndef __GENKSYMS__
 	blk_cleanup_queue(ctrl->ctrl.fabrics_q);
+#endif
 	blk_mq_free_tag_set(&ctrl->admin_tag_set);
 
 	kfree(ctrl->queues);
@@ -3155,11 +3157,13 @@ nvme_fc_init_ctrl(struct device *dev, st
 		goto out_free_queues;
 	ctrl->ctrl.admin_tagset = &ctrl->admin_tag_set;
 
+#ifndef __GENKSYMS__
 	ctrl->ctrl.fabrics_q = blk_mq_init_queue(&ctrl->admin_tag_set);
 	if (IS_ERR(ctrl->ctrl.fabrics_q)) {
 		ret = PTR_ERR(ctrl->ctrl.fabrics_q);
 		goto out_free_admin_tag_set;
 	}
+#endif
 
 	ctrl->ctrl.admin_q = blk_mq_init_queue(&ctrl->admin_tag_set);
 	if (IS_ERR(ctrl->ctrl.admin_q)) {
@@ -3235,7 +3239,9 @@ fail_ctrl:
 out_cleanup_admin_q:
 	blk_cleanup_queue(ctrl->ctrl.admin_q);
 out_cleanup_fabrics_q:
+#ifndef __GENKSYMS__
 	blk_cleanup_queue(ctrl->ctrl.fabrics_q);
+#endif
 out_free_admin_tag_set:
 	blk_mq_free_tag_set(&ctrl->admin_tag_set);
 out_free_queues:
--- a/drivers/nvme/host/rdma.c
+++ b/drivers/nvme/host/rdma.c
@@ -728,7 +728,9 @@ static void nvme_rdma_destroy_admin_queu
 {
 	if (remove) {
 		blk_cleanup_queue(ctrl->ctrl.admin_q);
+#ifndef __GENKSYMS__
 		blk_cleanup_queue(ctrl->ctrl.fabrics_q);
+#endif
 		blk_mq_free_tag_set(ctrl->ctrl.admin_tagset);
 	}
 	if (ctrl->async_event_sqe.data) {
@@ -770,11 +772,13 @@ static int nvme_rdma_configure_admin_que
 			goto out_free_async_qe;
 		}
 
+#ifndef __GENKSYMS__
 		ctrl->ctrl.fabrics_q = blk_mq_init_queue(&ctrl->admin_tag_set);
 		if (IS_ERR(ctrl->ctrl.fabrics_q)) {
 			error = PTR_ERR(ctrl->ctrl.fabrics_q);
 			goto out_free_tagset;
 		}
+#endif
 
 		ctrl->ctrl.admin_q = blk_mq_init_queue(&ctrl->admin_tag_set);
 		if (IS_ERR(ctrl->ctrl.admin_q)) {
@@ -819,8 +823,10 @@ out_cleanup_queue:
 	if (new)
 		blk_cleanup_queue(ctrl->ctrl.admin_q);
 out_cleanup_fabrics_q:
+#ifndef __GENKSYMS__
 	if (new)
 		blk_cleanup_queue(ctrl->ctrl.fabrics_q);
+#endif
 out_free_tagset:
 	if (new)
 		blk_mq_free_tag_set(ctrl->ctrl.admin_tagset);
--- a/drivers/nvme/host/tcp.c
+++ b/drivers/nvme/host/tcp.c
@@ -1653,7 +1653,9 @@ static void nvme_tcp_destroy_admin_queue
 	if (remove) {
 		free_opal_dev(ctrl->opal_dev);
 		blk_cleanup_queue(ctrl->admin_q);
+#ifndef __GENKSYMS__
 		blk_cleanup_queue(ctrl->fabrics_q);
+#endif
 		blk_mq_free_tag_set(ctrl->admin_tagset);
 	}
 	nvme_tcp_free_admin_queue(ctrl);
@@ -1674,11 +1676,13 @@ static int nvme_tcp_configure_admin_queu
 			goto out_free_queue;
 		}
 
+#ifndef __GENKSYMS__
 		ctrl->fabrics_q = blk_mq_init_queue(ctrl->admin_tagset);
 		if (IS_ERR(ctrl->fabrics_q)) {
 			error = PTR_ERR(ctrl->fabrics_q);
 			goto out_free_tagset;
 		}
+#endif
 
 		ctrl->admin_q = blk_mq_init_queue(ctrl->admin_tagset);
 		if (IS_ERR(ctrl->admin_q)) {
@@ -1718,8 +1722,10 @@ out_cleanup_queue:
 	if (new)
 		blk_cleanup_queue(ctrl->admin_q);
 out_cleanup_fabrics_q:
+#ifndef __GENKSYMS__
 	if (new)
 		blk_cleanup_queue(ctrl->fabrics_q);
+#endif
 out_free_tagset:
 	if (new)
 		blk_mq_free_tag_set(ctrl->admin_tagset);
--- a/drivers/nvme/target/loop.c
+++ b/drivers/nvme/target/loop.c
@@ -277,7 +277,9 @@ static void nvme_loop_destroy_admin_queu
 	clear_bit(NVME_LOOP_Q_LIVE, &ctrl->queues[0].flags);
 	nvmet_sq_destroy(&ctrl->queues[0].nvme_sq);
 	blk_cleanup_queue(ctrl->ctrl.admin_q);
+#ifndef __GENKSYMS__
 	blk_cleanup_queue(ctrl->ctrl.fabrics_q);
+#endif
 	blk_mq_free_tag_set(&ctrl->admin_tag_set);
 }
 
@@ -382,11 +384,13 @@ static int nvme_loop_configure_admin_que
 		goto out_free_sq;
 	ctrl->ctrl.admin_tagset = &ctrl->admin_tag_set;
 
+#ifndef __GENKSYMS__
 	ctrl->ctrl.fabrics_q = blk_mq_init_queue(&ctrl->admin_tag_set);
 	if (IS_ERR(ctrl->ctrl.fabrics_q)) {
 		error = PTR_ERR(ctrl->ctrl.fabrics_q);
 		goto out_free_tagset;
 	}
+#endif
 
 	ctrl->ctrl.admin_q = blk_mq_init_queue(&ctrl->admin_tag_set);
 	if (IS_ERR(ctrl->ctrl.admin_q)) {
@@ -428,7 +432,9 @@ static int nvme_loop_configure_admin_que
 out_cleanup_queue:
 	blk_cleanup_queue(ctrl->ctrl.admin_q);
 out_cleanup_fabrics_q:
+#ifndef __GENKSYMS__
 	blk_cleanup_queue(ctrl->ctrl.fabrics_q);
+#endif
 out_free_tagset:
 	blk_mq_free_tag_set(&ctrl->admin_tag_set);
 out_free_sq:
