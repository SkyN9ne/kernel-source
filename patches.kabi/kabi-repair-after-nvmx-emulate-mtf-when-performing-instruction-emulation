From: Dario Faggioli <dfaggioli@suse.com>
Date: Thu, 18 Feb 2021 18:09:05 +0000
Subject: kABI: repair, after "nVMX: Emulate MTF when performing instruction  emulation"
Patch-mainline: Never, kABI Fix
References: bsc#1182380

struct kvm_x86_ops is basically a kernel-internal data structure. It is
used by the LTTng out-of-tree modules, but no instance of that struct is
allocated in there.

All that is done in them, is reading the in-kernel allocated instance, by
accessing some members, such as kvm_x86_ops.get_exit_info() and
kvm_x86_ops->get_segment_base().

Therefore, extending the struct itself, without altering the offsets of
the current members can be considered safe.

Signed-off-by: Dario Faggioli <dfaggioli@suse.com>
---
 arch/x86/include/asm/kvm_host.h | 2 ++
 1 file changed, 2 insertions(+)

--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -1083,7 +1083,6 @@
 	void (*run)(struct kvm_vcpu *vcpu);
 	int (*handle_exit)(struct kvm_vcpu *vcpu);
 	void (*skip_emulated_instruction)(struct kvm_vcpu *vcpu);
-	void (*update_emulated_instruction)(struct kvm_vcpu *vcpu);
 	void (*set_interrupt_shadow)(struct kvm_vcpu *vcpu, int mask);
 	u32 (*get_interrupt_shadow)(struct kvm_vcpu *vcpu);
 	void (*patch_hypercall)(struct kvm_vcpu *vcpu,
@@ -1224,6 +1223,10 @@
 
 	bool (*need_emulation_on_page_fault)(struct kvm_vcpu *vcpu);
 	int (*enable_direct_tlbflush)(struct kvm_vcpu *vcpu);
+
+#ifndef __GENKSYMS__
+	void (*update_emulated_instruction)(struct kvm_vcpu *vcpu);
+#endif
 };
 
 struct kvm_arch_async_pf {
