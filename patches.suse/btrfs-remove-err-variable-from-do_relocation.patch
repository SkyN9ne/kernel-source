From: Nikolay Borisov <nborisov@suse.com>
Date: Tue, 24 Nov 2020 17:49:32 +0200
Subject: btrfs: remove err variable from do_relocation
Git-commit: 8df01fddb77998a46b1b59563e1c5d094dc2586a
Patch-mainline: v5.11-rc1
References: bsc#1187833

It simply gets assigned to 'ret' in case of errors. The flow of the
while loop is not changed by this commit since the few call sites
that 'goto next' will simply break from the loop.

Signed-off-by: Nikolay Borisov <nborisov@suse.com>
Reviewed-by: David Sterba <dsterba@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>
---
 fs/btrfs/relocation.c |   35 +++++++++++++----------------------
 1 file changed, 13 insertions(+), 22 deletions(-)

--- a/fs/btrfs/relocation.c
+++ b/fs/btrfs/relocation.c
@@ -2863,8 +2863,7 @@ static int do_relocation(struct btrfs_tr
 	u64 bytenr;
 	u64 generation;
 	int slot;
-	int ret;
-	int err = 0;
+	int ret = 0;
 
 	BUG_ON(lowest && node->eb);
 
@@ -2884,10 +2883,8 @@ static int do_relocation(struct btrfs_tr
 			if (!lowest) {
 				ret = btrfs_bin_search(upper->eb, key,
 						       upper->level, &slot);
-				if (ret < 0) {
-					err = ret;
+				if (ret < 0)
 					goto next;
-				}
 				BUG_ON(ret);
 				bytenr = btrfs_node_blockptr(upper->eb, slot);
 				if (node->eb->start == bytenr)
@@ -2899,10 +2896,8 @@ static int do_relocation(struct btrfs_tr
 		if (!upper->eb) {
 			ret = btrfs_search_slot(trans, root, key, path, 0, 1);
 			if (ret) {
-				if (ret < 0)
-					err = ret;
-				else
-					err = -ENOENT;
+				if (ret > 0)
+					ret = -ENOENT;
 
 				btrfs_release_path(path);
 				break;
@@ -2923,10 +2918,8 @@ static int do_relocation(struct btrfs_tr
 		} else {
 			ret = btrfs_bin_search(upper->eb, key, upper->level,
 					       &slot);
-			if (ret < 0) {
-				err = ret;
+			if (ret < 0)
 				goto next;
-			}
 			BUG_ON(ret);
 		}
 
@@ -2937,7 +2930,7 @@ static int do_relocation(struct btrfs_tr
 		"lowest leaf/node mismatch: bytenr %llu node->bytenr %llu slot %d upper %llu",
 					  bytenr, node->bytenr, slot,
 					  upper->eb->start);
-				err = -EIO;
+				ret = -EIO;
 				goto next;
 			}
 		} else {
@@ -2951,11 +2944,11 @@ static int do_relocation(struct btrfs_tr
 		eb = read_tree_block(fs_info, bytenr, generation,
 				     upper->level - 1, &first_key);
 		if (IS_ERR(eb)) {
-			err = PTR_ERR(eb);
+			ret = PTR_ERR(eb);
 			goto next;
 		} else if (!extent_buffer_uptodate(eb)) {
 			free_extent_buffer(eb);
-			err = -EIO;
+			ret = -EIO;
 			goto next;
 		}
 		btrfs_tree_lock(eb);
@@ -2966,10 +2959,8 @@ static int do_relocation(struct btrfs_tr
 					      slot, &eb);
 			btrfs_tree_unlock(eb);
 			free_extent_buffer(eb);
-			if (ret < 0) {
-				err = ret;
+			if (ret < 0)
 				goto next;
-			}
 			BUG_ON(node->eb != eb);
 		} else {
 			btrfs_set_node_blockptr(upper->eb, slot,
@@ -2995,19 +2986,19 @@ next:
 			drop_node_buffer(upper);
 		else
 			unlock_node_buffer(upper);
-		if (err)
+		if (ret)
 			break;
 	}
 
-	if (!err && node->pending) {
+	if (!ret && node->pending) {
 		drop_node_buffer(node);
 		list_move_tail(&node->list, &rc->backref_cache.changed);
 		node->pending = 0;
 	}
 
 	path->lowest_level = 0;
-	BUG_ON(err == -ENOSPC);
-	return err;
+	BUG_ON(ret == -ENOSPC);
+	return ret;
 }
 
 static int link_to_upper(struct btrfs_trans_handle *trans,
